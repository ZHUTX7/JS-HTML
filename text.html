<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <!-- Meta, title, CSS, favicons, etc. -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <body>

        <h2 th:text="${loginResult}"></h2>
        <input type="button" title="开启摄像头" value="开启摄像头" onclick="getMedia()" />
        <video id="video" width="500px" height="500px" autoplay="autoplay"></video>
        <canvas id="canvas" width="500px" height="500px"></canvas>
        <button id="snap" onclick="takePhoto()">拍照</button>
        <button onClick="exportCanvasAsPNG('canvas','p1');" type="button">下载图片</button>
        <script>
            //获得video摄像头区域
            let video = document.getElementById("video");

            function getMedia() {
                //创建一个constarint对象，里面有两个属性，1.video 2.audio
                //其中video是对象 audio是布尔类型
                let constraints = {
                    video: {
                        width: 500,
                        height: 500
                    },
                    audio: false
                };
                /*
                这里介绍新的方法:H5新媒体接口 navigator.mediaDevices.getUserMedia()
                这个方法会提示用户是否允许媒体输入,(媒体输入主要包括相机,视频采集设备,屏幕共享服务,麦克风,A/D转换器等)
                返回的是一个Promise对象。
                如果用户同意使用权限,则会将 MediaStream对象作为resolve()的参数传给then()
                如果用户拒绝使用权限,或者请求的媒体资源不可用,则会将 PermissionDeniedError作为reject()的参数传给catch()
                */
                let promise = navigator.mediaDevices.getUserMedia(constraints);
                promise.then(function(MediaStream) {
                    video.srcObject = MediaStream;
                    video.play();
                }).catch(function(PermissionDeniedError) {
                    console.log(PermissionDeniedError);
                })
            }

            function takePhoto() {
                //获得Canvas对象
                var imgURL;
                let canvas = document.getElementById("canvas");
                let ctx = canvas.getContext('2d');
                ctx.drawImage(video, 0, 0, 500, 500);
                // 第一种方法 采用data:application/octet-stream ,让浏览器识别为下载，有大小限制，12000*4000无法保存
                let image = new Image();
                image.src = canvas.toDataURL({
                    format: 'image/png',
                    quality: 1,
                    width: 500,
                    height: 500
                });
                var url = image.src.replace(/^data:image\/[^;]/, 'data:application/octet-stream');
                var canvasElement = document.getElementById("canvas");
                var MIME_TYPE = "image/png";
                //获取imgURL BASE64编码
                imgURL = canvasElement.toDataURL(MIME_TYPE);
                console.log(imgURL);
                //如果此处不进行转换，会导致+号丢失
                imgURL = encodeURIComponent(imgURL);
                //window.open(url);

                $.ajax({
                    url: "/GetFaceImgURL",
                    type: "POST",
                    dataType: "JSON",
                    contentType: "application/json; charset=utf-8",
                    data: {
                        'imgURL': imgURL,
                    },
                    async: false,
                    success: function(data) {
                        alert(data.loginResult);
                    },
                    error: function(jqXHR, textStatus, errorThrown) { //controller返回的data空或其他提示不存在
                        alert("人脸识别认证失败！");
                    }

                });


                // var xhttp = new XMLHttpRequest();
                // xhttp.onreadystatechange = function() {
                //     if (this.readyState == 4 && this.status == 200) {
                //         alert("识别成功!");
                //         location.href = '/index';
                //     }
                // };
                // xhttp.open("POST", "/GetFaceImgURL", true);
                // //通过AJax发送图片Base64

                // xhttp.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
                // xhttp.send("imgURL=" + imgURL);

                // return image;

            }
            //下载方法 ：传入canva标签的ID ， 图像保存后的文件名



            //通过AJax发送图片编码
            //function sendPhotoBase64(img_url) {
            //img_url = imgURL;

            // }
        </script>
    </body>

</html>